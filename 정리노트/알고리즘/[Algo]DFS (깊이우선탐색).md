# DFS (깊이우선탐색)

## 1. DFS -(Depth-First Search)란?

- 루트 노드 또는 어떤 임의의 노드(시작점)에서 시작해서 연결된 첫번째 분기에서 그 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
- 미로를 탐색할때 한 방향으로 ( 예를 들면 오른쪽) 갈 수 있을 때 까지 계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길(분기점)으로 돌아와 다음방향(예를 들면 왼쪽)으로 다시 같은 방식의 탐색을 진행하는 방법과 유사
- 주변의 모든 노드를 동시에 탐색하기 보다 한 방향으로 갈수 있을 때까지 깊게(deep)하게 탐색

<br>

<br>

## 2. DFS 사용할때와 장점 및 단점

- 존재하는 모든 노드를 방문 하고자 하는 경우에 이 방법을 사용한다.
- BFS보다 구현이 조금 더 용이하다.
- 단순한 검색의 속도를 비교하면 BFS보다 느리다.

<br>

<br>

## 3. DFS의 특징

- 자기 자신을 호출하는 순환 알고리즘 즉, 재귀형태를 가질 수 있다.
- 이 알고리즘을 구현할 때 주의해야할 점은 어떤 노드를 방문 했었는지 여부를 반드시 검사해야한다.(무한루프 주의)
- ![image-20210928194333633]([Algo]DFS (깊이우선탐색).assets/image-20210928194333633.png)

<br>

<br>

## 4. DFS의 시간복잡도

- 시간복잡도는 인접 리스트와 인접 행렬로 표현될때가 차이가 발생한다.
- 인접리스트로 표현된 그래프의 시간복잡도 __O(N+E)__
- 인접행렬로 표현된 그래프의 시간 복잡도 __O(N²)__

<br>

<br>

## 5.인접리스트 방식

```python
#행(Row)이 3개인 2차원 리스트로 인접 리스트 표현
graph = [[] for _ in range(3)]

#노드 0에 연결된 노드 정보 저장(노드, 거리)
graph[0].append((1, 7)) #튜플 형태로 저장
graph[0].append((2, 5))

#노드 1에 연결된 노드 정보 저장(노드, 거리)
graph[1].append((0, 7))

# 노드 2에 연결된 노드 정보 저장(노드, 거리)
graph[2].append((0,5))

print(graph)
>>> [[(1, 7), (2, 5)], [(0, 7)], [(0, 5)]]

```

<br>

<br>

## 6. 구현방식

```python
# 1. 재귀적 방식
def dfs(graph, start, visited):
    #현재 노드를 방문처리
    visited[start] =True
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[start]:
        if not visited[i]:
            dfs(graph, i , visited)
#각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

#각 노드가 방문된 정보를 리스트 자료형으로 표현
visited = [False] * 9

# DFS 호출
dfs(graph, 1, visited)
```

